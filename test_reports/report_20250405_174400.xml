<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="5" failures="3" skipped="0" tests="12" time="1.000" timestamp="2025-04-05T17:44:01.439622-07:00" hostname="Mac.lan"><testcase classname="tests.integration.test_db_integration.TestDatabaseIntegration" name="test_init_db_creates_tables" time="0.006"><error message="failed on setup with &quot;AttributeError: module 'db' has no attribute 'DATABASE'&quot;">self = &lt;tests.integration.test_db_integration.TestDatabaseIntegration object at 0x102b11850&gt;, test_db_path = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmpf5dz6m1y'

    @pytest.fixture(scope="function")
    def setup_test_db(self, test_db_path):
        """Set up the test database with test data"""
        # Override the database path for testing
&gt;       original_db_path = db.DATABASE
E       AttributeError: module 'db' has no attribute 'DATABASE'

tests/integration/test_db_integration.py:32: AttributeError</error></testcase><testcase classname="tests.integration.test_db_integration.TestDatabaseIntegration" name="test_store_and_retrieve_problem" time="0.004"><error message="failed on setup with &quot;AttributeError: module 'db' has no attribute 'DATABASE'&quot;">self = &lt;tests.integration.test_db_integration.TestDatabaseIntegration object at 0x102fde7b0&gt;, test_db_path = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmps2npl2vl'

    @pytest.fixture(scope="function")
    def setup_test_db(self, test_db_path):
        """Set up the test database with test data"""
        # Override the database path for testing
&gt;       original_db_path = db.DATABASE
E       AttributeError: module 'db' has no attribute 'DATABASE'

tests/integration/test_db_integration.py:32: AttributeError</error></testcase><testcase classname="tests.integration.test_db_integration.TestDatabaseIntegration" name="test_store_and_retrieve_solution" time="0.005"><error message="failed on setup with &quot;AttributeError: module 'db' has no attribute 'DATABASE'&quot;">self = &lt;tests.integration.test_db_integration.TestDatabaseIntegration object at 0x102fde990&gt;, test_db_path = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmp993_x8aw'

    @pytest.fixture(scope="function")
    def setup_test_db(self, test_db_path):
        """Set up the test database with test data"""
        # Override the database path for testing
&gt;       original_db_path = db.DATABASE
E       AttributeError: module 'db' has no attribute 'DATABASE'

tests/integration/test_db_integration.py:32: AttributeError</error></testcase><testcase classname="tests.integration.test_db_integration.TestDatabaseIntegration" name="test_get_problems_by_lesson" time="0.004"><error message="failed on setup with &quot;AttributeError: module 'db' has no attribute 'DATABASE'&quot;">self = &lt;tests.integration.test_db_integration.TestDatabaseIntegration object at 0x102fdeb40&gt;, test_db_path = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmpxmbixp9x'

    @pytest.fixture(scope="function")
    def setup_test_db(self, test_db_path):
        """Set up the test database with test data"""
        # Override the database path for testing
&gt;       original_db_path = db.DATABASE
E       AttributeError: module 'db' has no attribute 'DATABASE'

tests/integration/test_db_integration.py:32: AttributeError</error></testcase><testcase classname="tests.integration.test_db_integration.TestDatabaseIntegration" name="test_delete_problem_and_solutions" time="0.005"><error message="failed on setup with &quot;AttributeError: module 'db' has no attribute 'DATABASE'&quot;">self = &lt;tests.integration.test_db_integration.TestDatabaseIntegration object at 0x102fdecf0&gt;, test_db_path = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmpc6efmsjj'

    @pytest.fixture(scope="function")
    def setup_test_db(self, test_db_path):
        """Set up the test database with test data"""
        # Override the database path for testing
&gt;       original_db_path = db.DATABASE
E       AttributeError: module 'db' has no attribute 'DATABASE'

tests/integration/test_db_integration.py:32: AttributeError</error></testcase><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_language_execution[python-print('Hello from Python')-Hello from Python\n]" time="0.009"><failure message="TypeError: cannot unpack non-iterable NoneType object">self = &lt;tests.integration.test_language_execution.TestMultiLanguageExecution object at 0x102f5df10&gt;, flask_app = &lt;Flask 'app'&gt;
setup_temp_dir = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmp8ik38zko', language = 'python', code = "print('Hello from Python')", expected_output = 'Hello from Python\n'

        @pytest.mark.parametrize("language,code,expected_output", [
            ("python", "print('Hello from Python')", "Hello from Python\n"),
            ("java", """
    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello from Java");
        }
    }
    """, "Hello from Java\n"),
            ("cpp", """
    #include &lt;iostream&gt;
    
    int main() {
        std::cout &lt;&lt; "Hello from C++" &lt;&lt; std::endl;
        return 0;
    }
    """, "Hello from C++\n")
        ])
        def test_language_execution(self, flask_app, setup_temp_dir, language, code, expected_output):
            """Test code execution in different languages"""
            # Skip if we can't import run module
            try:
                import run
                # Replace jsonify with a simple dict return to avoid Flask context issues
                def mock_run_code(code, input_data, language):
                    # This is a simplified version of run_code that doesn't use Flask's jsonify
                    try:
                        # Mock the actual execution logic with our test parameters
                        return {"output": expected_output.strip(), "error": None}
                    except Exception as e:
                        return {"error": str(e), "output": None}
    
                # Patch the run_code function with our simplified version
                with patch('run.run_code', side_effect=mock_run_code):
                    # Now use the patched version - no need to import directly
                    from run import run_code
            except ImportError:
                pytest.skip("run module not found - skipping test")
    
            # Create realistic mock structures depending on language
            with patch('subprocess.run') as mock_run, \
                 patch('tempfile.NamedTemporaryFile') as mock_temp_file, \
                 patch('os.path.join', return_value=os.path.join(setup_temp_dir, f"test.{language}")):
    
                # Configure the mocks
                mock_proc = MagicMock()
                mock_proc.stdout = expected_output.encode('utf-8')
                mock_proc.stderr = b''
                mock_proc.returncode = 0
                mock_run.return_value = mock_proc
    
                # For Java and C++ we need to handle file creation
                if language in ["java", "cpp"]:
                    # Mock the temporary file
                    mock_file = MagicMock()
                    mock_file.name = os.path.join(setup_temp_dir,
                                                 "Main.java" if language == "java" else "main.cpp")
                    mock_temp_file.return_value.__enter__.return_value = mock_file
    
                # Run the code
                result = run_code(code, "", language)
    
                # Verify the results
                assert result["error"] is None
                assert result["output"] == expected_output.strip()
    
                # Verify language-specific command execution
                if language == "python":
                    # For Python, should run with python interpreter
&gt;                   args, kwargs = mock_run.call_args
E                   TypeError: cannot unpack non-iterable NoneType object

tests/integration/test_language_execution.py:114: TypeError</failure></testcase><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_language_execution[java-\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(&quot;Hello from Java&quot;);\n    }\n}\n-Hello from Java\n]" time="0.005"><failure message="assert 0 &gt;= 2&#10; +  where 0 = len([])">self = &lt;tests.integration.test_language_execution.TestMultiLanguageExecution object at 0x1014926c0&gt;, flask_app = &lt;Flask 'app'&gt;
setup_temp_dir = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmpf42oiamc', language = 'java'
code = '\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println("Hello from Java");\n    }\n}\n', expected_output = 'Hello from Java\n'

        @pytest.mark.parametrize("language,code,expected_output", [
            ("python", "print('Hello from Python')", "Hello from Python\n"),
            ("java", """
    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello from Java");
        }
    }
    """, "Hello from Java\n"),
            ("cpp", """
    #include &lt;iostream&gt;
    
    int main() {
        std::cout &lt;&lt; "Hello from C++" &lt;&lt; std::endl;
        return 0;
    }
    """, "Hello from C++\n")
        ])
        def test_language_execution(self, flask_app, setup_temp_dir, language, code, expected_output):
            """Test code execution in different languages"""
            # Skip if we can't import run module
            try:
                import run
                # Replace jsonify with a simple dict return to avoid Flask context issues
                def mock_run_code(code, input_data, language):
                    # This is a simplified version of run_code that doesn't use Flask's jsonify
                    try:
                        # Mock the actual execution logic with our test parameters
                        return {"output": expected_output.strip(), "error": None}
                    except Exception as e:
                        return {"error": str(e), "output": None}
    
                # Patch the run_code function with our simplified version
                with patch('run.run_code', side_effect=mock_run_code):
                    # Now use the patched version - no need to import directly
                    from run import run_code
            except ImportError:
                pytest.skip("run module not found - skipping test")
    
            # Create realistic mock structures depending on language
            with patch('subprocess.run') as mock_run, \
                 patch('tempfile.NamedTemporaryFile') as mock_temp_file, \
                 patch('os.path.join', return_value=os.path.join(setup_temp_dir, f"test.{language}")):
    
                # Configure the mocks
                mock_proc = MagicMock()
                mock_proc.stdout = expected_output.encode('utf-8')
                mock_proc.stderr = b''
                mock_proc.returncode = 0
                mock_run.return_value = mock_proc
    
                # For Java and C++ we need to handle file creation
                if language in ["java", "cpp"]:
                    # Mock the temporary file
                    mock_file = MagicMock()
                    mock_file.name = os.path.join(setup_temp_dir,
                                                 "Main.java" if language == "java" else "main.cpp")
                    mock_temp_file.return_value.__enter__.return_value = mock_file
    
                # Run the code
                result = run_code(code, "", language)
    
                # Verify the results
                assert result["error"] is None
                assert result["output"] == expected_output.strip()
    
                # Verify language-specific command execution
                if language == "python":
                    # For Python, should run with python interpreter
                    args, kwargs = mock_run.call_args
                    assert "python" in args[0][0].lower()
                elif language == "java":
                    # For Java, should compile with javac and run with java
                    calls = mock_run.call_args_list
&gt;                   assert len(calls) &gt;= 2
E                   assert 0 &gt;= 2
E                    +  where 0 = len([])

tests/integration/test_language_execution.py:119: AssertionError</failure></testcase><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_language_execution[cpp-\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; &quot;Hello from C++&quot; &lt;&lt; std::endl;\n    return 0;\n}\n-Hello from C++\n]" time="0.006"><failure message="assert 0 &gt;= 2&#10; +  where 0 = len([])">self = &lt;tests.integration.test_language_execution.TestMultiLanguageExecution object at 0x101491e50&gt;, flask_app = &lt;Flask 'app'&gt;
setup_temp_dir = '/var/folders/8y/w2yb8j213d9_hvmy43nlvt0m0000gn/T/tmp7glbapkn', language = 'cpp'
code = '\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; "Hello from C++" &lt;&lt; std::endl;\n    return 0;\n}\n', expected_output = 'Hello from C++\n'

        @pytest.mark.parametrize("language,code,expected_output", [
            ("python", "print('Hello from Python')", "Hello from Python\n"),
            ("java", """
    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello from Java");
        }
    }
    """, "Hello from Java\n"),
            ("cpp", """
    #include &lt;iostream&gt;
    
    int main() {
        std::cout &lt;&lt; "Hello from C++" &lt;&lt; std::endl;
        return 0;
    }
    """, "Hello from C++\n")
        ])
        def test_language_execution(self, flask_app, setup_temp_dir, language, code, expected_output):
            """Test code execution in different languages"""
            # Skip if we can't import run module
            try:
                import run
                # Replace jsonify with a simple dict return to avoid Flask context issues
                def mock_run_code(code, input_data, language):
                    # This is a simplified version of run_code that doesn't use Flask's jsonify
                    try:
                        # Mock the actual execution logic with our test parameters
                        return {"output": expected_output.strip(), "error": None}
                    except Exception as e:
                        return {"error": str(e), "output": None}
    
                # Patch the run_code function with our simplified version
                with patch('run.run_code', side_effect=mock_run_code):
                    # Now use the patched version - no need to import directly
                    from run import run_code
            except ImportError:
                pytest.skip("run module not found - skipping test")
    
            # Create realistic mock structures depending on language
            with patch('subprocess.run') as mock_run, \
                 patch('tempfile.NamedTemporaryFile') as mock_temp_file, \
                 patch('os.path.join', return_value=os.path.join(setup_temp_dir, f"test.{language}")):
    
                # Configure the mocks
                mock_proc = MagicMock()
                mock_proc.stdout = expected_output.encode('utf-8')
                mock_proc.stderr = b''
                mock_proc.returncode = 0
                mock_run.return_value = mock_proc
    
                # For Java and C++ we need to handle file creation
                if language in ["java", "cpp"]:
                    # Mock the temporary file
                    mock_file = MagicMock()
                    mock_file.name = os.path.join(setup_temp_dir,
                                                 "Main.java" if language == "java" else "main.cpp")
                    mock_temp_file.return_value.__enter__.return_value = mock_file
    
                # Run the code
                result = run_code(code, "", language)
    
                # Verify the results
                assert result["error"] is None
                assert result["output"] == expected_output.strip()
    
                # Verify language-specific command execution
                if language == "python":
                    # For Python, should run with python interpreter
                    args, kwargs = mock_run.call_args
                    assert "python" in args[0][0].lower()
                elif language == "java":
                    # For Java, should compile with javac and run with java
                    calls = mock_run.call_args_list
                    assert len(calls) &gt;= 2
                    compile_call = calls[0]
                    run_call = calls[1]
                    assert "javac" in compile_call[0][0][0].lower()
                    assert "java" in run_call[0][0][0].lower()
                elif language == "cpp":
                    # For C++, should compile with g++ and run binary
                    calls = mock_run.call_args_list
&gt;                   assert len(calls) &gt;= 2
E                   assert 0 &gt;= 2
E                    +  where 0 = len([])

tests/integration/test_language_execution.py:127: AssertionError</failure></testcase><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_input_handling[python-a = int(input())\nb = int(input())\nprint(a + b)-5\n3-8]" time="0.006" /><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_input_handling[java-\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        System.out.println(a + b);\n    }\n}\n-5\n3-8]" time="0.005" /><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_input_handling[cpp-\n#include &lt;iostream&gt;\n\nint main() {\n    int a, b;\n    std::cin &gt;&gt; a &gt;&gt; b;\n    std::cout &lt;&lt; a + b &lt;&lt; std::endl;\n    return 0;\n}\n-5\n3-8]" time="0.006" /><testcase classname="tests.integration.test_language_execution.TestMultiLanguageExecution" name="test_compilation_error_handling" time="0.004" /></testsuite></testsuites>